----------------
------Java------
----------------
一、Java概述
    （一）Java语言发展史
    （二）Java语言跨平台原理
        平台：Windows、Mac、Linux
        跨平台：Java程序可以在任意平台运行
        跨平台原理：在需要运行Java应用程序的操作系统上，安装一个与操作系统对应的Java虚拟机JVM即可
    （三）JRE和JDK
        JRE是Java程序的运行时环境，包含JVM和运行时所需要的核心类库
        JDK是Java程序开发工具包，包含JRE和开发人员使用的工具（编译工具Javac.exe、运行工具java.exe）
    （四）JDK的下载和安装
二、第一个程序
    （一）常用DOS命令
        盘符名称: 盘符切换
        dir 查看当前路径下的内容
        cd 目录 进入单级目录
        cd .. 回退到上一级目录
        cd 目录1\目录2 进入多级目录
        cd \ 回到盘符目录
        cls 清屏
        exit 退出窗口
    （二）Path环境变量的配置
        新建JAVA_HOME变量，变量值为JDK的安装目录 
        Path变量添加%JAVA_HOME%\bin
    （三）HelloWorld案例
        Java程序开发流程：编写程序、编译程序、运行程序
        HelloWorld.java
        public class HelloWorld {
            public static void main(String[] args) {
                System.out.println("HelloWorld");
            }
        }
        javac HelloWorld.java
        java HelloWorld
    （四）HelloWorld案例常见问题
    （五）Notepad软件的安装和使用
三、基础语法
    （一）注释
    （二）关键字
    （三）常量
    （四）数据类型
        基本数据类型：
            整数、浮点数、字符、布尔
        引用数据类型：
            类、接口、数组
    （五）变量
        long类型变量定义的时候，为了防止整数过大，后面要加L；
        float类型的变量定义的时候，为了防止类型不兼容，后面要加F；
    （六）标识符
    （七）类型转换
四、运算符
    （一）算术运算符
        当连续进行"+"操作时，从左到右逐个执行
    （二）赋值运算符
    （三）自增自减运算符
    （四）关系运算符
    （五）逻辑运算符
    （六）三元运算符
五、数据输入
    （一）导包：import java.util.Scanner
    （二）创建对象：Scanner sc = new Scanner(System.in);
    （三）接收数据：int i = sc.nextInt();
六、分支语句
    （一）流程控制
    （二）if语句
    （三）switch语句
七、循环语句
    （一）for循环语句
    （二）while循环语句
    （三）do...while循环语句
    （四）控制跳转语句
    （五）循环嵌套语句
    （六）Random语句
        导包：import java.util.Random;
        创建对象：Random r = new Random();
        获取随机数：int number = r.nextInt(10);//[0, 10)
八、IDEA
    （一）IDEA概述和安装
        IDEA全程IntelliJ IDEA，是用于Java语言开发的集成环境；
        集成环境：把代码编写、编译、运行、调试等多种功能综合到一起的开发工具；
    （二）IDEA中的HelloWorld
    （三）IDEA中项目结构
    （四）IDEA中内容辅助键和快捷键
    （五）IDEA中模块的操作
九、数组
    （一）数组定义格式
        格式1：数据类型[] 变量名
        格式2：数据类型 变量名[]
    （二）数组初始化之动态初始化
        Java种的数组必须先初始化然后才能调用；
        初始化即为数组元素分配内存空间，并为数组元素赋值
        动态初始化：int[] arr = new int[3];
    （三）数组元素访问
    （四）内存分配
    （五）数组初始化之静态初始化
        静态初始化：int[] arr = {1, 2, 3};
    （六）数组操作的两个常见小问题
    （七）数组常见操作
        获取数组元素的数量：数组名.length
十、方法
    （一）方法概述
    （二）方法的定义和调用
    （三）带参数方法的定义和调用
    （四）带返回值方法的定义和调用
    （五）方法的注意事项
    （六）方法重载
        方法重载指同一个类种定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：
            多个方法在同一个类种；
            多个方法具有相同的方法名；
            多个方法的参数不相同，类型不同或者数量不同；
    （七）方法的参数传递
十一、Debug
十二、类和对象
    （一）类和对象
        类是Java程序的基本组成单位
    （二）对象内存图
    （三）成员变量和局部变量
    （四）封装
    （五）构造方法
十三、字符串
    （一）API
    （二）String
        1.String类在java.lang包下，所以使用的时候不需要导包
        2.Java程序种所有的双引号字符串都是String类的实例
        3.使用==做比较
            基本类型：比较的是数据值是否相同
            引用类型：比较的是地址值是否相同
        4.字符串比较:boolean equal();
        5.获取字符串指定索引的字符：char charAt();
        6.获取字符串的长度：int length();
        7.键盘输入字符串
            Scanner sc = new Scanner(System.in);
            String line = sc.nextLine();
    （三）StringBuilder
        1.如果对字符串进行拼接操作，每次拼接都会构建一个新的String对象，既耗时又浪费空间，可通过Java中的StringBuilder类来解决此问题
        2.StringBuilde是一个可变的字符串类，可以看成是一个容器
        3.String和StringBuilder的区别
            String：内容是不可变的
            StringBuilder：内容是可变的
        4.添加方法：StringBuilder append();//添加数据，并返回对象本身
        5.反转方法：StringBuilder reverse();//返回相反的字符串序列
        6.StringBuilder和String相互转换
            StringBuilder转换为String：String toString();//通过toString()就可以实现把StringBuilder转换为String
            String转换为StringBuilder：StringBuilder();//通过构造方法就可以实现把String转换为StringBuilder
十四、集合基础（ArrayList<E>）（import java.util.ArrayList）
    1.集合类的特点：提供一种存储空间可变的存储类型，存储的数据容量可以发生改变
    2.添加方法：boolean add(E e);//将指定元素追加到此集合的末尾
    3.添加方法：void add(int index, E element);//在此集合中指定位置插入指定的元素
    4.ArrayList集合常用方法
        boolean remove(Object o);//删除指定的元素，返回删除是否成功
        E remove(int index);//删除指定索引处的元素，返回被删除的元素
        E set(int index, E element);//修改指定索引的元素，返回被修改的元素
        E get(int index);//返回指定索引处的元素
        int size();//返回集合中元素个数
十五、继承
    1.在子类方法中访问一个变量
        子类局部范围找
        子类成员范围找
        父类成员范围找
        如果都没有就报错
    2.super
        super.成员变量;//用于访问父类中的成员变量
        super();//访问父类构造方法
        super.成员方法();//访问父类成员方法
        子类构造方法的第一条语句默认都是super();
    3.通过子类对象访问一个方法
        子类成员范围找
        父类成员范围找如果都没有就报错
    4.Java中继承的注意事项
        Java中类只支持单继承，不支持多继承；
        Java中类支持多层继承
十六、修饰符
    （一）包
        包就是文件夹，作用是对类进行分类管理
        格式：package 报名;（多级包用.分开）
        例：package com.itheima;
    （二）导包
        格式：import 包名;
    （三）修饰符
        1.权限修饰符
            同一类中：private、默认、protected、public;
            同一个包中子类无关类：默认、protected、public;
            不同包的子类：protected、public;
            不同包的无关类：public;
        2.状态修饰符
            final
                修饰方法：表示最终方法，不能被重写;
                修饰变量：表示常量，不能被再次赋值;
                    变量是基本类型：则指数据值不能发生改变；
                    变量是引用类型：则指地址值不能发生改变；
                修饰类：表示最终类，不能被继承;
            static
                特点：被类的所有对象共享;
                静态成员方法只能访问静态成员;
十七、多态
    1.多态中成员的访问特点：
        成员变量：编译看左边，执行看左边；
        成员方法：编译看左边，执行看右边；
    2.多态中的转型
        向上转型：从子到父
        向下转型：从父到子
十八、抽象类
    抽象类和抽象方法必须用abstract修饰；
    抽象类不能实例化；
    抽象类的子类要么从写抽象类中的所有抽象方法，要么也是抽象类；
十九、接口
    接口就是一种公共的规范标准，只要符合标准，大家都可以使用
    Java中的接口更多的体现在对行为的抽象
    1.接口的特点：
        1.1接口用关键字interface修饰；
            public interface 接口名{}；
        1.2类实现接口用implements表示
            public class 类名 implements 接口名{}；
        1.3接口不能实例化
            可参照多态的形式，通过实现类对象实例化，这叫接口多态；
            多态的形式：具体类多态，抽象类多态，接口多态；
            多态的前提：又继承或者实现关系，有方法重写，有父类/接口引用指向子/实现类对象；
        1.4接口的实现类
            要么重写接口中的所有抽象方法
            要么是抽象类
    2.接口的成员特点
        2.1成员变量
            只能是常量；
            默认修饰符：public static final；
        2.2构造方法
            接口没有构造方法，因为接口只要是对行为进行抽象的，是没有具体存在的；
            一个类如果没有父类，默认继承自Object类；
        2.3成员方法
            只能是抽象方法；
            默认修饰符：public abstract；
    3.类和接口的关系
        3.1类和类的关系
            继承关系，只能单继承，单可以多层继承；
        3.2类和接口的关系
            实现关系，可以单实现，也可以多实现，还可以在继承一个类同时实现多个接口；
        3.3接口和接口的关系
            继承关系，可以单继承，可以可以多继承；
    4.抽象类和接口的区别
        成员区别
            抽象类：变量，常量；有构造方法；有抽象方法，有非抽象方法；
            接口：常量；抽象方法；
        关系区别
            类和类：继承，单继承；
            类和接口：实现，可以单实现，也可以多实现；
            接口和接口：继承，单继承，多继承；
        设计理念区别
            抽象类：对类抽象，包括属性，行为；
            接口：对行为抽象，主要是行为；
二十、形参和返回值
    1.类名作为形参和返回值
        方法的形参是类名，其实需要的是该类的对象；
        方法的返回值是类名，其实返回的是该类的对象；
    2.抽象类名作为形参和返回值
        方法的形参是抽象类名，其实需要的是该抽象类的子类对象；
        方法的返回值是抽象类名，其实返回的是该抽象类的子类对象；
    3.接口名作为形参和返回值
        方法的形参是接口名，其实需要的是该接口的实现类对象；
        方法的返回值是接口名，其实返回的是该接口的实现类对象；
二十一、内部类
    1.内部类就是在一个类中定义一个类；
    2.内部类的访问特点：
        内部类可以直接访问外部类的成员，包括私有；
        外部类要访问内部类的成员，必须创建对象；
    3.内部类分类：
        3.1成员内部类
            创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
        3.2局部内部类
            局部内部类是在方法中定义的类，所有外界是无法直接使用，需要在方法内部创建对象使用；
            该类可以直接访问外部类的成员，也可以访问方法内的局部变量；
            匿名内部类
                前提：存在一个类或者接口，这里的类可以是具体类或者抽象类；
                格式：new 类名或者接口名(){
                    重写方法;
                };
                本质：是一个继承了该类或者实现了该接口的子类匿名对象；
二十二、常用API
    （一）Math 
        Math包含执行基本数字运算的方法；
        Math类常用方法：
            int abs(int a);//返回参数的绝对值
            double ceil(double a);//向上取整
            double floor(double a);//向下取整
            int round(float a);//四舍五入
            int max(int a, int b);//返回较大值
            int min(int a, int b);//返回较小值
            double pow(double a, double b);//返回a的b此幂的值
            double random();//返回随机值[0.0， 1.0)
    （二）System
        void exit();//终止当前运行的JVM，非0表示异常终止
        long currentTimeMillis();//返回当前时间
    （三）Object
        Object是类层次结构的根，每个类都可以将Object作为超类，所有类都直接或者间接的继承自该类；
        Object类的常用方法:
            String toString();//返回对象的字符串表现形式，建议所有子类重写该方法，自动生成
            boolean equals(Object obj);//比较对象是否相等，默认比较地址，重写可以比较内容，自动生成；
    （四）Array
        Arrays类的常用方法：
            String toString(int[] a);//返回指定数组的内容的字符串表示形式
            void sort(int[] a);//按照数字顺序排列指定的数组
    （五）基本类型包装类
        1.将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据，如用于基本数据类型与字符串之间的转换
            基本数据类型-包装类
            byte--------Byte;
            short-------Short;
            int---------Integer;
                Integer i = Integer.valueOf(100);//获取对象
                int和String的相互转换：
                    int转换为String：String valueOf(int i);//返回int参数的字符串表示形式，该方法是String类中的方法
                    String转换为int：int parseInt(String s);//将字符串解析为int类型。该方法是Integer类中的方法
            long--------Long;
            float-------Float;
            double------Double;
            char--------Charater;
            boolean-----Boolean;
        2.自动装箱和拆箱
            装箱：把基本数据类型转换为对应的包装类类型；
            拆箱：把包装类类型转换为对应的基本数据类型；
            使用前需判断对象是否为null
    （六）日期类
        1.Date类
            1.1构造方法
                Date();//分配一个Date对象，并初始化，以便代表它被分配的时间，精确到毫秒
                Date(long date);//分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数
            1.2Date类的常用方法
                long getTime();//获取的是日期从1970年1月1日00：00：00到现在的毫秒值
                void setTime(long time);//设置时间，给的是毫秒值
        2.SimpleDateFormat类
            2.1SimpleDateFormat是一个具体的类，用于区域设置敏感的方式格式化和解析日期
                y：年
                M：月
                d：日
                H：时
                m：分
                s：秒
            2.2构造方法
                SimpleDateFormat();//构造一个SimpleDateFormat，使用默认模式和日期格式
                SimpleDateFormat(String pattern);//构造一个SimpleDateFormat使用给定的模式和默认的日期格式
            2.3格式化和解析日期
                格式化（从Date到String）：String format(Date date);//将日期格式化成日期/时间字符串
                解析（从String到Date）：Date parse(String sourse);//从给定字符串的开始解析文本以生成日期
        3.Calendar
            3.1常用方法
                int get(int field);//返回给定日历字段的值
                add(int field, int amount);//根据日历的规则，将指定的时间量添加或减去给定的日历字段
                set(int year, int month, int date);//设置当前日历的年月日
二十三、异常（异常就是程序出现了不正常的情况）
    1.异常体系
        Throwable:
            Error:严重问题，不需要处理
            Exception:称为异常类，它表示程序本身可以处理的问题
                RuntimeException:在编译期时不检查的，出现问题后，需要我们回来修改代码
                非RuntimeException:编译器必须处理的，否则程序不能通过编译，也就不能运行
    2.JVM的默认处理方案
        如果程序出现了问题，我们没有做任何处理，最终JVM会做默认处理
            把异常的名称，异常的原因及异常出现的位置等信息输出在控制台；
            程序停止执行；
    3.异常处理：
        try...catch...
            try{
                可能出现异常的代码;
            }catch(异常类名 变量名){
                异常的处理代码;
            }
        throws
            throws 异常类名;//这个格式是跟在方法的括号后面的
    4.Throwable的成员方法
        String getMessage();//返回此Throwable的详细信息字符串
        String toString();//返回此可抛出的简短描述
        void printStackTrace();//把异常的错误信息输出在控制台
    5.编译时异常和运行时异常的区别
        Java中异常的分类：
        编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译
        运行时异常：无需显示处理，也可以和编译时异常一样处理
    6.自定义异常
        public class 异常类名 extends Exception {
            无参构造
            有参构造
        }
        throws和throw的区别
            throws:
                用在方法声明后面，跟的是异常类名；
                表示抛出异常，由该方法的调用者来处理；
                表示出现异常的一种可能性，并不一定会发生这些异常；
            throw：
                用在方法体内，跟的是异常对象名；
                表示抛出异常，由方法体内的语句处理；
                执行throw一定抛出了某种异常
二十四、集合进阶
    （一）Collection（单列）
        1.概述
            是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection元素；
            JDK不提供子接口的任何直接实现，它提供更具体的子接口实现；
        2.创建Collection集合的对象
            多态方式
            具体的实现类ArrayList
        3.Collection集合常用方法
            boolean add(E e);//
            boolean remove(Object o);//删除指定元素添加元素
            void clear();//清空集合中的元素
            boolean contains(Object o);//判断集合是否存在指定元素
            boolean isEmpty();//判断集合是否为空
            int size();//集合的长度
        4.Collection集合的遍历
            Iterator：迭代器，集合的专用遍历方式；
                Iterator<E> iterator();//返回此集合中元素的迭代器，通过iterator()得到
                迭代器是通过集合的iterator()方法得到的，所有它是依赖于集合存在的
            Iterator中的常用方法
                E next();//返回迭代中的下一个元素 
                boolean hasNext();//如果迭代具有更多元素，则返回true
    （二）List（可重复）
        1.概述
            有序集合，用户可以精确控制列表中每个元素的插入位置，用户可以通过整数索引访问元素，并搜索列表中的元素；
            与set集合不同，列表通常允许重复的元素；
        2.特点
            有序：存储和取出的元素顺序一致；
            可重复：存储的元素可以重复；
        3.特有方法
            void add(int index, E element);//在此集合中的指定位置插入指定的元素
            E remove(int index);//删除指定索引处的元素，返回被删除的元素
            E set(int index, E element);//修改指定索引处的元素，返回被修改的元素
            E get(int index);//返回指定索引处的元素
        4.并发修改异常（ConcurrentModifycationException）
            产生原因：迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致；
            解决方案：用for循环遍历，然后用集合对象做对应的操作即可；
        5.ListIterator
            允许沿任意方向遍历列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置；
            ListIterator的常用方法
                E next();//返回迭代中的下一个元素
                boolean hasNext();//如果迭代器具有更多元素，则返回true
                E previous();//返回列表中的上一个元素
                boolean hasPrevious();//如果此列迭代器在相反方向遍历列表时具有更多元素则返回true
                void add(E e);//将指定的元素插入列表
        6.增强for循环
            格式：for(元素数据类型 变量名：数组或者Collection集合) {
                使用变量
            }
        7.List集合子类特点
            List集合常用子类：
                ArrayList：底层数据结构是数组，查询快，增删慢；
                LinkedList：底层数据结构是链表，查询慢，增删快；
                    LinkList集合特有功能：
                        void addFirst(E e);//在开头插入指定元素
                        void addLast(E e);//将元素追加到末尾
                        E getFirst();//返回第一个元素
                        E getLast();//返回最后一个元素
                        E removeFirst();//删除并返回第一个元素
                        E removeLast();//删除并返回最后一个元素
    （三）Set（不可重复）
        1.特点：不包含重复元素的集合；没有带索引的方法，不能使用普通for循环遍历；
        2.哈希值是JDK根据对象地址或者字符串或者数字算出来的int类型的数值；
            Object类中有一个方法可以获取对象的哈希值：int hashCode();
        3.HashSet集合
            底层数据结构是哈希表；
            对集合的迭代顺序不作任何保证，即不保证存储和取出的元素顺序一致；
            没有带索引的方法，索引不能用普通for遍历；
            不包含重复元素；
        4.LinkedHashSet
            哈希表和链表实现的Set接口，具有可预测的迭代次序；
            有链表保证元素有序；
            有哈希表保证元素唯一；
        5.TreeSet
            TreeSet()://根据其元素的自然排序进行排序
            TreeSet(Comparator comparator);//根据指定的比较器进行排序
            没有带索引的方法，所以不能用普通for循环；
            不包含重复元素；
        6.比较器排序Comparator的使用
            比较器排序就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1, T o2)方法，重写是注意排序规则必须按照要求的主要条件和次要条件来写；
    （四）泛型
        将类型由原来的具体的类型参数化，然后在使用或调用时传入具体的类型
        好处：把运行时期的问题提前到了编译期间；避免了强制类型转换；
        1.泛型类
            格式：修饰符 class 类名<类型> {}
        2.泛型方法
            格式：修饰符 <类型> 返回值类型 方法名(类型 变量名) {}
        3.泛型接口
            格式：修饰符 interface 接口名<类型> {}
        4.类型通配符（为了表示各种泛型List的父类，可以使用类型通配符）
            类型通配符：<?>//表示元素类型未知的List，可以匹配任何类型
            类型通配符上限：<? extends 类型>//表示类型是某类型或者其子类型
            类型通配符下限：<? super 类型>//表示类型是某类型或者其父类型
        5.可变参数（又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的）
            格式：修饰符 返回值类型 方法名(数据类型... 变量名) {}
            这里的变量其实是一个数组；
            如果一个方法有多个参数，包含可变参数，可变参数要放在最后；
            public static <T> List<T> asList(T... a);//返回由指定数组支持的固定大小的列表；不能做增删操作，可以修改
            public static <E> List<E> of(E... elements);//返回包含任意数组元素的不可变列表；不能做增删改操作
            public static <E> Set<E> of(E... elements);//返回一个包含任意数量元素的不可变集合；不能做增删操作，没有改方法
    （五）Map（双列）
        1.概述
            Interface Map<K, V> K:键的类型；V:值的类型；
            将键映射到值的对象；不能包含重复的键；每个键可以映射到最多一个值；
            多态方式创建Map集合对象；具体实现类HashMap；
        2.基本功能
            V put(K key, V value);//添加元素
            V remove(Object key);//根据键删除键值对元素
            void clear();//清空集合
            boolean containsKey(Object key);//判断集合是否包含指定的键
            boolean containsValues(Object value);//判断集合是否包含指定的值
            boolean isEmpty();//判断集合是否为空
            int size();//返回集合中键值对的个数
            V get(Object key);//根据键获取值
            Set<K> keySet();//获取所有键的集合
            Collection<V> values();//获取所有值的集合
            Set<Map.Entry<K, V>> entrySet();//获取所有键值对对象的集合
        3.遍历
            方式1：获取所有键的集合，用keySet()实现；
                遍历键集合，获取到每一个键。用增强for实现；
                根据键找值，用get(Object key)实现；
            方式2：获取所有键值对对象集合Set<Map.Entry<K, V>> entrySet();
                遍历键值对对象集合，得到每一个键值对对象；
                根据键值对对象获取键和值，用getKey()和getValue();
    （六）Collections（针对集合操作的工具类）
        1.常用方法    
            void sort(List<T> list);//将指定列表按升序排序
            void reverse(List<T> list);//反转指定列表元素
            void shuffle(List<T> list);//随机排列指定列表
二十五、IO流
    （一）File
        1.概述（File是文件和目录路径名的抽象表示）
            文件和目录是可以通过File封装成对象的；
            对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已，它可以是存在的也可以是不存在的，将来是要通过具体的操作把这个路径的内容转换为具体存在的；
        2.构造方法
            File(String pathname);//通过将给定的路径名字符串转换为抽象路径名来创建新的File实例
            File(String parent, String child);//从父路径名字符串和子路径名字符串创建新的File实例
            File(File parent, String child);//从父抽象路径名和子路径名字符串创建新的File实例
        3.File类创建功能
            boolean createNewFile();//创建文件
            boolean mkdir();//创建目录
            boolean mkdirs();//创建多级目录
        4.File类判断和获取功能
            boolean isDirectory();//判断File是否为目录
            boolean isFile();//判断File是否为文件
            boolean exists();//判断File是否存在
            String getAbsolutePath();//返回绝对路径名字符串
            String getPath();//将此抽象路径名转换为路径名字符串
            String getName();//返回目录或文件的名称
            String[] list();//返回目录和文件的名称字符串数组
            File[] listFiles();//返回目录和文件的File对象数组
        5.File类删除功能
            boolean delete();//删除文件或目录
            如果一个目录中有内容，应先删除目录中的内容，最后再删除目录
        6.递归（指的是方法定义中调用方法本身的现象）
            把一个复杂的问题层层转换为一个与原问题相似的规模较小的问题来求解；
            递归出口：没有则会出现内存溢出；
            递归规则：与原问题相似的规模较小的问题；
    （二）字节流
        1.IO流分类
            按照数据的流向：输入流（读数据）、输出流（写数据）；
            按照数据类型：字节流（字节输入流、字节输出流）、字符流（字符输入流、字符输出流）；
        2.字节流写数据
            2.1字节流抽象基类：
                InputStream:这个抽象类是表示字节输入流的所有类的超类；
                OutputStream：这个抽象类是表示字节输出流的所有类的超类；
            2.2字节输出流写数据：
                创建字节输出流对象；
                调用字节输出流对象的写数据方法；
                释放资源；
            2.3字节流写数据的方式：
                void write(int b);//将指定字节写入文件，一次写一个字节
                void write(byte[] b);//将数组的字节数据写入文件
                void write(byte[] b, int off, int len);//从自定数组off偏移量开始项文件写入len长度个字节的数据
            2.4换行符：
                Windows:\r\n
                Linux:\n
                Mac:\r
            2.5追加写入：
                FileOutputStream(String name, boolean append);
            2.6异常处理：
                finally：在异常处理时提供finally块来执行所有清除操作，被finally控制的语句一定会执行，除非JVM退出
                try{
                }catch() {
                }finally{
                }
        3.字节流读数据
            创建字节输入流对象；
            调用字节输入流对象的读数据方法；
            释放资源；
        4.字节缓冲流
            BufferedOutputStream：缓冲输出流，通过设置这样的输出流，应用程序可以向底层输出流写数据，而不必为写入每个字节导致底层系统的调用；
            BufferedInputStream：缓冲输入流；
            构造方法：
                BufferedOutputStream(OutputStream out);//字节缓冲输出流
                BufferedInputStream(InputStream in);//字节缓冲输入流
    （三）字符流（字符流=字节流+编码表）
        1.字符流抽象基类
            Reader：字符输入流的抽象类
            Writer：字符输出流的抽象类
        2.字符流中的两个类：
            InputStreamReader
            OutputStreamWriter
        3.字符流写数据
            void write(int c);//写一个字符
            void write(char[] cbuf);//写一个字符数组
            void write(char[] cbuf, int off, int len);//写入字符数组的一部分
            void write(String str);//写一个字符串
            void write(String str, int off, int len);//写一个字符串的一部分
            flush();//刷新流，还可以继续写数据
            close();//关闭流，关闭前先刷新流
        4.字符流读数据
            int read();//一次读一个字符数据
            int read(char[] cbuf);//一次读一个字符数组的数据
        5.字符缓冲流
            BufferedWriter：字符缓冲输出流，构造方法：BufferedWriter(Writer out);
            BufferedReader：字符缓冲输入流，构造方法：BufferedReader(Reader in);
            特有功能：
                BufferedWriter: void newLine();//写一行分隔符
                BufferedReader: public String readLine();//读一行文字
    （四）特殊操作流
        1.标准输入输出流
            System类中有两个静态成员变量：
                public static final InputStream in;//标准输入流
                public static final PrintStream out;//标准输出流，
            自己实现键盘录入数据：
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            Java提供的类实现键盘录入数据：
                Scanner sc = new Scanner(System.in);
        2.打印流
            分类：字节打印流、字符打印流；
            特点：只负责输出数据，不负责读取数据；有自己的特有方法；
            PrintStream(String fileName);//使用指定的文件名创建新的打印流
            构造方法：
                PrintWriter(String fileName);//使用指定的文件名创建一个新的PrintWriter,而不需要自动执行刷新
                PrintWriter(Writer out, boolean autoFlush);//out:字符输出流;autoFlush:值为真则println、printf、format将刷新输出缓冲区
        3.对象序列化流
            3.1对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象；
                这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据、对象中存储的属性等；
                字节序列写到文件后，相当于文件中持久保存了一个对象的信息；反之该字节序列还可以从文件中读取回来，重构对象，对他进行反序列化；
                3.1.1对象序列化流：ObjectOutputStream
                    将Java对象的原始数据类型和图形写入OutputStream，可以通过使用流的文件来实现对象的持久存储；
                    如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象；
                    构造方法：ObjectOutputStream(OutputStream out);//创建一个写入指定OutputStream的ObjectOutputStream
                    序列化对象方法：void writeObject(Object obj);//将指定的对象写入ObjectOutputStream
                    注意：一个对象要想被序列化，该对象所属的类必须实现Serializable接口；Serializable是一个标记接口，实现该接口不需要重写任何方法；
                         若一个对象序列化后，修改了对象所属类，读文件会抛出InvalidClassException异常,解决方法是给对象所属类加private static final long serialVersionUID = 42L;
                         类的成员变量用transient修饰，表示该成员变量不参与序列化过程；
                3.1.2对象反序列化流：ObjectInputStream
                    构造方法：ObjectInputStream(InputStream in);//创建从指定的InputStream读取的ObjectInputStream
                    反序列化对象方法：Object readObject();//从ObjectInputStream读取一个对象
            3.2Properties
                3.2.1Properties作为集合的特有方法：
                    Object setProperty(String key, String value);//设置集合的键和值
                    String getProperty(String key);//搜索指定键的值
                    Set<String> stringPropertyNames();//返回列表的键集合
                3.2.2Properties和IO流结合的方法：
                    void load(InputStream inStream);//从输入字节流读取列表
                    void load(Reader reader);//从出入字符流读取列表
                    void store(OutputStream out, String comments);//将列表写入Properties中，以适合使用load(InputStream)方法的格式写入输出字节流
                    void store(Writer writer, String comments);//将列表写入Properties中，以适合使用load(Reader)方法的格式写入输出字符流
二十六、多线程
    （一）实现多线程
        1.进程：是正在运行的程序
            是系统进行资源分配和调用的独立单位；
            每一个进程都有它自己的内存空间和系统资源；
        2.线程：是进程中的单个顺序控制流，是一条执行路径
            单线程：一个进程如果只有一条执行路径，则称为单线程程序；
            多线程：一个进程如果有多条执行路径，则称为多线程程序；
        3.多线程的实现方式
            3.1继承Thread类
                3.1.1实现
                    定义一个类MyThread继承Thread类；
                    在MyThread类中重写run()方法；（run()封装线程执行的代码；start()启动线程，然后由JVM调用此线程的run()方法）
                    创建MyThread类的对象；
                    启动线程；
                3.1.2设置和获取线程名称
                    void setName(String name);//将此线程的名称更改为name
                    String getName();//返回此线程的名称
                    通过构造方法也可以设置线程名称
                    public static Thread currentThread();//返回对当前正在执行的线程对象的引用
                3.1.3线程调度
                    分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU时间片；
                    抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些；
                    假如计算机只有一个CPU，那么CPU在某个时刻只能执行一条指令，线程只有得到CPU时间片，即使用权，才能执行指令。所以说多线程程序的执行是由随机性，因为谁抢到CPU的使用权是不一定的；
                    public final int getPriority();//返回此线程的优先级
                    public final void setPriority(int newPriority);//更改此线程的优先级
                        线程默认优先级是5；范围是1-10；
                        线程优先级高仅表示获取CPU时间片的几率高；
                3.1.4线程控制
                    Static void sleep(long millis);//使用当前正在执行的线程停留指定的毫秒
                    void join();//等待这个线程死亡
                    void setDaemon(boolean on);//将此线程标记为守护线程，当运行的线程都是守护线程时，JVM将退出
                3.1.5线程生命周期
                                                      ___________
                                                     |没有执行资格|
                                 sleep()方法时间    / |没有执行权  | |\-
                                 到/阻塞方式结束   /   -----------     \  sleep()/其他阻塞式方法
                                                 /       阻塞          \       
                                               |/_                      \                              
                    _________  start()  __________      抢到CPU执行权    __________  stop()   ________
                    |创建线程|--------->|有执行资格|-------------------->|有执行资格|--------->|线程死亡|
                    |  对象  |          |没有执行权|<--------------------|有执行权  | run()结束|变成垃圾|
                    ---------           ----------  其他线程抢走CPU执行权 ----------           --------
                        新建               就绪                             运行                死亡
            3.2实现Runnable接口
                3.2.1实现
                    定义一个类MyRunnable实现Runnable接口；
                    在MyRunnable类中重写run()方法；
                    创建MyRunnable类的对象；
                    创建Thread类的对象，把MyRunnable对象作为构造方法的参数；
                    启动线程；
                3.2.2好处：
                    避免了Java单继承的局限性；
                    适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好地体现了面向对象的设计思想； 
    （二）线程同步
        1.同步代码块
            格式：synchronized(任意对象) {//相当于给代码加锁，任意对象可以看作是一把锁
                多条语句操作共享数据的代码;
            }
            好处：解决了多线程的数据安全问题；
            弊处：当线程很多时，因为每个线程都会去判断同步上的锁，耗费资源，降低程序的运行效率；
        2.同步方法
            格式：synchronized 返回值类型 方法名(方法参数) {}
            同步方法的锁对象：this
            同步静态方法：static synchronized 返回值类型 方法名(方法参数) {}
            同步静态方法的锁对象：类名.class
        3.线程安全的类
            StringBuffer；
            Vector；
            Hashtable；
        4.Lock锁
            Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作
            Lock提供了获得锁和释放锁的方法:
                void lock();//获得锁
                void unlock();//释放锁
            Lock是接口,需用实现类ReentrantLock来实例化
            ReentranLock();//创建一个ReentranLock的实例
    （三）生产者消费者
        生产者消费者问题主要包括两类线程：
            一类是生产者线程用于生产数据；
            一类是消费者线程用于消费数据；
        为了解耦生产者和消费者的关系，通常会采用共享的数据区域；
        Object类的等待和唤醒方法：
            void wait();//导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法
            void nitify();//唤醒正在等待对象监视器的单个线程
            void notifyAll();//唤醒正在等待对象监视器的所有线程
二十七、网络编程
    （一）网络编程入门
        1.计算机网络：是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统；
        2.网络编程：在网络通信协议下，实现网络互联的不同计算机上运行的程序间可以进行数据交换；
        3.网络编程三要素：IP地址（设备的标识，IPv4和IPv6）、端口（应用程序的标识，0-65535）、协议（UDP协议（无连接通信协议）和TCP协议（传输控制协议））；
        4.InetAddress:此类表示Internet协议IP地址
            static InetAddress gerByName(String host);//确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址
            String getHostName();//获取此IP地址的主机名
            String getHostAddress();//返回文本显示中的IP地址
        5.TCP三次握手
            第1次握手：客户端向服务器段发出连接请求，等待服务器确认；
            第2次握手：服务器端向客户端回送一个响应，通知客户端收到了连接请求；
            第3次握手：客户端再次向服务器端发送确认信息，确认连接；
    （二）UDP通信程序
        1.原理
            UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象；
            因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器端的概念；
            Java提供了DatagramSocket类作为基于UDP协议的Socket；
        2.发送数据
            创建发送端的Socket对象：DatagramSocket();
            创建数据，并把数据打包：DatagramPacket(byte[] buf, int length, InetAddress address, iny port);
            调用DatagramSocket对象的方法发送数据：void send(DatagramSocket p);
            关闭发送端：void close();
        3.接收数据
            创建接收端的Socket对象：DatagramSocket(int port);
            创建一个数据包，用于接收数据：DatagramPacket(byte[] buf, int length);
            调用DatagramSocket对象的方法接收数据：void receive(DatagramPacket p);
            解析数据包，并把数据在控制台显示：byte[] getData(); int getLength();
            关闭接收端：void close();
    （三）TCP通信程序
        1.原理
            TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路；
            一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信；
            Java对基于TCP协议的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信；
            Java为客户端提供了Socket类，为服务器端提供了ServerSocket类；
        2.发送数据
            创建客户端的Socket对象：Socket(String host, int port);
            获取输出流，写数据：OutputStream getOutputStream();
                shutdowOutput();//标记数据发送结束
            释放资源：void close();
        3.接收数据
            创建服务器端的Socket对象：
            监听客户端连接，返回一个Socket对象：ServerSocket(int port);
            获取输入流，读数据，并把数据显示在控制台：InputStream getInputStream();
            释放资源：void close();
二十八、Lambda表达式
    1.格式：(形式参数)->{代码块}
    2.组成Lambda表达式的三要素：
        ():没有内容表示方法的形参为空
        ->:用箭头指向要做的事情
        {}:包含一段代码，方法体中的内容；
    3.省略规则：
        参数类型可以省略。有多个参数时不能只省略一个；
        参数只有一个，()也可以省略；
        代码块的语句只有一条，{}和;和return都可以省略；
    4.注意事项：
        使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法；
        必须有上下文环境，才能推导出Lambda对应的接口；
            根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -> System.out.prinln("Lambda表达式");
            根据调用方法的参数得知Lambda对应的接口：new Thread(() -> System.out.prinln("Lambda表达式")).start();
    5.Lambda表达式和匿名内部类的区别
        5.1所需类型不同
            匿名内部类：可以是接口，也可以是抽象类，还可以是具体类；
            Lambda表达式：只能是接口；
        5.2使用限制不同
            如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类；
            如果接口中多余一个抽象方法，只能使用匿名内部类；
        5.3实现原理不同
            匿名内部类：编译之后，产生一个单独的.class字节码文件；
            Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的适合动态生成；
二十九、接口组成
    1.接口的组成：常量、抽象方法、默认方法、静态方法、私有方法
    2.默认方法
        格式：public default 返回值类型 方法名(参数列表) {}
        注意事项：默认方法不是抽象方法，所以不强制被重写，但可以被重写，重写的适合去掉default；public可以省略；
    3.静态方法
        格式：public static 返回值类型 方法名(参数列表) {}
        注意事项：静态方法只能通过接口名调用，不能通过实现类名或者对象名调用；public可以省略；
    4.私有方法
        格式1：private 返回值类型 方法名(参数列表) {}
        格式2：private static 返回值类型 方法名(参数列表) {}
        注意事项：默认方法可以调用私有的静态方法和非静态方法；静态方法只能调用私有的静态方法；
三十、方法引用
    1.方法引用符：::
    2.推到与省略
        如果使用Lambda，那么根据"可推导就是可省略"的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导；
        如果使用方法引用，也是同样可以根据上下文进行推导；
        方法引用是Lambda的孪生兄弟
    3.引用类方法
        格式：类名::静态方法
    4.引用对象的实例方法
        格式：对象::成员方法
    5.引用类的实例方法
        格式：类名::成员方法
    6.引用构造器
        格式：类名::new
三十一、函数式接口(有且仅有一个抽象方法的接口， @FunctionalInterface)
    常用的函数式接口
        Supplier接口
            Supplier<T>接口也被称为生产型接口，如果指定了接口的泛型类型，那么接口中的get方法就会生成什么类型的数据供使用；
            T get();//获得结果
        Consumer接口
            Consumer<T>接口也被称为消费型接口，消费的数据类型有泛型决定；
            void accept(T t);//对给定的参数执行操作
            default Consumer<T> andThen(Consumer after);//返回一个组合的Consumer，依次执行操作，然后执行after操作
        Predicate接口
            Predicate<T>接口通常用于判断参数是否满足指定的条件；
            boolean test(T t);//对给定的参数进行判断，返回一个布尔值
            default Predicate<T> negate();//返回一个逻辑否定，对应逻辑非
            default Predicate<T> and(Predicate other);//返回一个组合判断，对应短路与
            default Predicate<T> or(Predicate other);//返回一个组合判断，对应短路或
        Function接口
            Function<T, R>接口通常用于对参数进行处理，转换，然后返回一个新的值；
            R apply(T t);//将次函数应用于给定的参数
            default<V> Function andThen(Function after);//返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果
三十二、Stream流
    使用Stream流的方式完成过滤操作：list.stream().filter(s -> s.startWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);
    1.Stream流的生成方式
        Collection集合可以使用stream()生成流；
        Map集合可用间接生成流；
        数组可以通过Stream接口的静态方法of(T values)生成流；
    2.Stream流的常见中间操作方法
        Stream<T> filter(Predicate predicate);//用于对流中的数据进行过滤
            Predicate接口中的方法：boolean test(T t);//对给定的参数进行判断，返回一个布尔值
        Stream<T> limit(long maxSize);//返回此流中的元素组成的流，截取前指定参数个数的数据
        Stream<T> skip(long n);//跳过指定参数个数的数据，返回由该流的剩余元素组成的流
        static <T> Stream<T> concat(Stream a, Stream b);// 合并a和b两个流为一个流
        Stream<T> distinct();//返回由该流的不同元素组成的流
        Stream<T> sorted();//返回由此流的元素组成的流，根据自然排序
        Stream<T>  sorted(Comparator comparator);//返回由此流的元素组成的流，根据Comparator排序
        <R> Stream<R> map(Function mapper);//返回由给定函数应用于此流的元素的结果组成的流
            Function接口中的方法：R apply();//
        IntStream mapToInt(ToIntFunction mapper);//返回一个IntStream其中包含将给定函数应用于此流的元素的结果，IntStream表示原始int流，ToIntFunction表示接口中的方法:int applyAsInt(T value);
    3.Stream流的常见终结操作方法
        void forEach(Consumer action);//对此流的每个元素执行操作
            Consumer接口中的方法：void accept(T t);//对给定的参数执行此操作
        long count();//返回此流中的元素数
    4.Stream流的收集操作
        4.1Stream流的收集方法
            R collect(Collectors collector);
        4.2工具类Conllectors提供了具体的收集方式
            public static <T> Collector toList();//把元素收集到List集合中
            public static <T> Collector toSet();//把元素收集到Set集合中
            public static Collector toMap(Function keyMapper, Function valueMapper);//把元素收集到Map集合中
三十三、反射
    （一）类加载器
        1.类加载：当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对进行初始化，这三个步骤统称为类加载或类初始化；
            类加载：
                就是将class文件读入内存，并为之创建一个java.lang.Class对象；
                任何类被使用时，系统都会为之建立一个java.lang.Class对象；
            类的连接：
                验证阶段：用于检验被加载的类是否又正确的内部结构，并和其他类协调一致；
                准备阶段：负责为类的类变量分配内存，并设置默认初始化值；
                解析阶段：将类的二进制数据中的符号引用替换为直接引用；
            类的初始化：
                在该阶段，主要就是对类变量进行初始化；
        2.类的初始化步骤：
            假如类还未被加载和连接，则程序先加载并连接该类；
            假如该类的直接父类还未被初始化，则先初始化其直接父类；
            假如类中有初始化语句，则系统依次执行这些初始化语句；
        3.类的初始化时机：
            创建类的实例；
            调用类的类方法；
            访问类或者接口的类变量，或者为该类变量赋值；
            使用反射方式来强制创建某个类或者接口对应的java.lang.Class对象；
            初始化某个类的子类；
            之间使用java.exe命令来运行某个主类；
        4.类加载器的作用：
            赋值将.class文件加载到内存中，并为之生成对应的java.lang.Class对象；
        5.JVM的类加载机制：全盘负责、父类委托、缓存机制；
        6.类加载器：
            ClassLoader:是负责加载类的对象；
            Java运行时具有以下内置类加载器：Boostrap class loader;Platform class loader;System class loader;
            类加载器的继承关系：System的父类加载器为Platform，而Platform的父类加载器为Boostrap；
            ClassLoader的两个方法：
                static ClassLoader getSystemClassLoader();//返回用于委派的系统类加载器
                ClassLoader getParent();//返回父类加载器进行委派
    （二）反射
        Java反射机制：是指在运行时去获取一个类的变量和方法信息，然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大增强程序的灵活性。
        1.获取Class类对象
            使用类的class实现获取该类对应的CLass对象；
            调用对象的getClass()方法，返回该对象所属类对应的Class对象；
            使用Class类中的静态方法forName(String className)；
        2.反射获取构造方法并使用
            2.1Class类中用于获取构造方法的方法：
                Constructor<?>[] getConstructors();//返回所有公共构造方法对象的数组
                Constructor<?>[] getDeclaredConstructors();//返回所有构造方法对象的数组
                Constructor<T> getConstructor(Class<?>...parameterTypes);//返回单个公共构造方法对象
                Constructor<T> getDeclaredConstructor(Class<?>...parameterTypes);//返回单个构造方法对象
            2.2Constructor类中用于创建对象的方法：
                T newInstance(Object...initargs);//根据指定的构造方法创建对象
            基本数据类型也可以通过.class得到对应的Class类型；
            public void setAccessible(boolean flag);//值为true，取消访问检查；
        3.反射获取成员变量并使用
            3.1Class类中用于获取成员变量的方法：
                Field[] getFields();//返回所有公共成员变量对象的数组
                Field[] getDeclaredFields();//返回所有成员变量对象的数组
                Field getField(String name);//返回单个公共成员变量对象
                Field getDeclaredField(String name);//返回单个成员变量对象
            3.2Field类中用于给成员变量赋值的方法：
                void set(Object obj, Object value);//给obj对象的成员变量赋值为value
        4.反射获取成员方法并使用
            4.1Class类中用于获取成员方法的方法：
                Method[] getMethods();//返回所有公共成员方法对象的数组，包括继承的
                Method[] getDeclaredMethods();//返回所有成员方法对象的数组，不包括继承的
                Method getMethod(String name,Class<?>...parameterTypes);//返回单个公共成员方法对象
                Method getDeclaredMethod(String name,Class<?>...parameterTypes);//返回单个成员方法对象
            4.2Method类中用于调用成员方法的方法：
                Object invoke(Object obj, Object...args);//调用obj对象的成员方法，参数是args，返回值是Object类型
三十四、模块化
    （一）模块化的基本使用
        1.创建模块；
        2.在模块的src目录下新建一个名为module-info.java的描述性文件，该文件专门定义模块名，访问权限，模块依赖等信息，描述文件中使用模块导出和模块依赖来进行配置使用；
        3.模块中所有为导出的包都是私有的，他们是不能在模块之外被访问的；
            模块导出格式：export 包名；
        4.一个模块要访问其他的模块，必须明确指定依赖哪些模块，为明确指定依赖的模块不能访问；
            模块依赖格式：requires 模块名；
    （二）模块服务的使用
        服务：从Java6开始，Java就提供了一种服务机制，允许服务提供者和服务使用者之间完成解耦，简单的说，就是服务使用者值面向接口编程，但不清楚服务提供者的实现类；
        Java9的模块化系统则进一步简化了Java的服务机制，Java9允许将服务接口定义在一个模块中，并使用uses语句来声明该服务接口，然后针对不同的服务实现类，这些服务实现类可以分布在不同的模块中，服务实现模块则使用provides语句为服务接口指定实现类；服务使用者只需要面向接口编程即可。
三十五、进制
    （一）进制基础知识
        二进制：在Java中以0b开头
        八进制：在Java中以0开头
        十进制：整数默认是十进制的
        十六进制：在Java中以0x开头
    （二）进制转换
        十进制到R进制转换：
            重复相除法（除基取余，直到商为0，余数反转）；
        java内置进制转换
            java.lang.Integer类中的静态方法：
                public static String toBinaryString(int i);//返回一个数的二进制形式
                public static String toOctalString(int i);//返回一个数的八进制形式
                public static String toHexString(int i);//返回一个数的十六进制形式
                public static String toString(int i, int radix);//返回i的radix进制形式
    （三）有符号数据表示法
        原码表示法：
            使用0表示正数，1表示负数；
            规定符号位位于数值第一位，其余位是数值位；
        反码表示法：
            正数的反码和原码相同；
            负数的反码就是它的原码除符号位外，按位取反；
        补码表示法：
            正数的补码和原码相同；
            负数的补码等于反码+1；
        在计算机中，存储和运算采用的都是补码进行的，计算过程中符号进位舍弃
    （四）整数强制转换之数据溢出
    （五）浮点数存储
        十进制浮点数转换为二进制浮点数：
            整数部分重复相除法，小鼠部分重复相乘法；
    （六）浮点数运算之结果有误
        避免浮点数计算精度丢失：
            使用java.math.BingDecimal中的方法；
            构造方法：BigDecimal(String val);
            成员方法：public BigDecimal subtract(BigDecimal subtrahend);//减法操作
三十六、位运算符
    1.逻辑位运算符：
        &:位与（同1为1，其余为0）
        |:位或（同0为0，其余为1）
        ^:位异或（相同为0，不同为1）
        ~:位取反（0变为1，1变为0）
    2.移位运算符：
        <<:左移（高位丢弃，低位补0）
        >>:右移（整数左补0，负数左补1）
        >>>:无符号右移（无论该数是正或负，右移后左补0）
三十七、Java8日期API
    1.Java8日期API的优点：
        Date如果不格式化，输出的日期可读性差，而Java8的时间类直接输出可读性好；
        Date存在线程安全问题；而Java8的时间类都是线程安全的；
    2.Java8新增日期类：
        LocalDate;//年月日
        LocalTime;//时分秒
        LocalDateTime;//年月日时分秒
        Instant;//代表的是时间戳
        DateTimeFormatter;//用于时间的格式化和解析
        Duration;//计算两个时间间隔
        Period;//计算两个日期间隔
    3.LocalDateTime格式化和解析
        格式化：String format(DateTimeFormatter formatter);//使用指定的格式化程序格式化此日期时间
        解析：static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter);//使用特定格式化程序从文本字符串中获取LocalDateTime的实例
        DateTimeFormatter:没有构造方法，用以下静态方法获取日期格式化对象
            public static DateTimeFormatter ofPattern(String pattern);//使用指定的模式创建格式化程序
三十八、设计模式
    1.概述
        设计模式是一套被反复使用、多人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性；
        设计模式和具体的语言无关，学习设计模式就是要建立面向对象思想，尽可能的面向接口编程，低耦合，高内聚，使设计的程序可复用；
    2.单例设计模式
        单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供；
        在系统内存中之存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例无疑可以提高系统性能；
        保证类在内存中只有一个对象：
            把构造方法私有；
            在成员位置自己创建一个对象；
            通过一个公共的方法提供访问；
        分类：
            饿汉式：类一加载就创建对象（常用）；
            懒汉式：用的时候才去创建对象；
三十九、枚举（是指将变量的值一一列出来，变量的值只限于列举出来的值的范围内）
    1.格式：
        public enum 枚举类名{
            枚举项1,枚举项2,枚举项3;
        }
    2.注意事项： 
        定义枚举类要用关键字enum；
        所有枚举类都是Enum的子类；
        枚举类的第一行必须是枚举项，最后一个枚举项后的分号是可以省略的；
        枚举类可以有构造器，但必须是private的；
        枚举类可以有抽象方法，但枚举项必须重写该方法；
        枚举在switch语句中的使用；
四十、BigDecimal(用于小数的精确运算)
    构造方法：BigDecimal(String val);
    四则运算：add(big Decimal b);//加法
             subtract(BigDecimal b);//减法
             multiply(BigDecimal b);//乘法
             divide(BigDecimal b);//除法
                pbulic BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式);
                RoundingMode.UP:进一法
                RoundingMode.FLOOR:去尾法
                RoundingMode.HALF_UP:四舍五入
四十一、注解
    注解：也叫元数据，一种代码级别的说明，可以说明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明；
    1.注解和注释：
        注解：用来说明程序，给计算机看的；
        注释：用来对程序进行说明的文字，给程序员看的；
    2.Java常见注解：
        @Override
            用于指定方法是重写父类的方法，只能修饰方法，不能修饰其他程序元素；
        @Deprecated
            用于表示某个程序已过时，当其他程序使用已过期的类、方法时，编译器将会给出警告；
        @SuppressWarnings
            指示被该注解修饰的程序元素取消显示指定的编译器警告；
        @FunctionalInterface
            只能用来修饰接口，表示该接口是一个函数式接口；
    3.元注解：对注解进行注解的注解
        @Retention
            只能用于修饰注解定义，用于指定被修饰的注解可以保留多长时间；
        @Target
            只能用于修饰注解定义，用于指定被修饰的注解竜用于修饰哪些程序单元；
    4.自定义注解(本质是一个接口，该接口默认继承Annotation接口)
        4.1定义格式：
            元注解
            public @interface 注解名称{
                属性列表;
            }   
        4.2注解的属性：
            属性：接口中的抽象方法；
            格式：返回值类型 属性名称();
        4.3注解属性类型可以有以下列出的类型：
            基本数据类型；
            String;
            枚举类型；
            注解类型；
            Class类型；
            以上类型的一维数组类型；
    5解析注解
        获取字节码文件对象：
            Class<MyAnnotation> c = MyAnnoTationTest.class;
        获取字节码对象上的注解信息：
            MyAnnotation annotation = c.getAnnotation(MyAnnotation.class);
        解析注解：
            String name = annotation.name();
            int age = anntation.age();
四十二、XML
    XML是一种可扩展的标记语言；
    标记语言：通过标签来描述数据的一门语言；
    可扩展：标签的名字可以自己定义；
    1.语法规则：
        xml文件的后罪名普遍都是xml；
        xml要有文档声明，文档声明必须是第一行第一列；
        xml必须存在一个根标签，并且有且仅有一个；
    2.XML解析思想
        就是从xml中获取到数据，常见的解析思想为DOM；
        DOM:Document对象代表整个xml文档，其中标签为Element，文本为Text，属性为Attribute，这几个对象存在一个公共的父类Node；
    3.解析技术：
        DOM4J使用步骤：
            创建学生类；
            导入jar包；
            创建解析器；
            通过解析器读取xml文档数据，得到Document对象；
            获得根节点元素对象；
            从根节点下查找其他的节点元素，读取数据；
    4.文档约束：
        xml文档约束技术就是来限定xml文件中可使用的标签以及属性；
        xml常见的约束技术有dtd、schema；
四十三、单元测试
    在程序中一个单元可以是一个完整的模块，但他通常是一个单独的方法或者程序；
    在面向对象的编程中，一个单元通常是整个界面，例如类或单个方法；
    JUnit是Java编程语言的单元测试框架；
    1.编码约定：
        类放在test包中；
        在test包下创建和包名相同的包；
        类名用XxxTest结尾；
        方法用testMethod命名；
    2.步骤：
        和src同级建立test目录，并修改该目录为Test Sorces Root;
        在test目录下建包；
        在包下新建类：XxxTest;
        在类中编写第一个测试方法testMethod();
            方法修饰符：public void testMethod();
        导入junit-4.12.jar和hamcrest-core-1.3.jar包；
        在方法上添加@Test注解；
        运行测试方法；
        or使用断言改进测试方法；
    3.断言：即判断
        Junit测试框架中的Assert类就是实现断言的工具；
        查看两个对象是否相等：
            public static void assertEquals(Object expected, Object actual);
            public static void assertNotEquals(Object unexpected, Object actual);
    4.Junit常用注解：
        @Test:
        @Before:修饰实例方法，针对每一个测试用例执行，但在执行测试用例之前；
        @After:修饰实例方法，针对每一个测试用例执行，但在执行测试用例之后；
        @BeforeClass:修饰静态方法，方法首先执行，并只执行一次，用于初始化资源；
        @AfterClass:修饰静态方法，方法最后执行，并只执行一次，用于释放资源；
四十四、图形化界面
    （一）AWT
    （二）SWing
